%% Simulate Fisher Info Matrix and Test Parameter Identification
%
% Calculate estimates of the Fisher information matrix. The Fisher matrix
% is a property of the model itself, and is independent of any data. It
% represents the maximum amount of information one can hope for to find in
% the data in case the data are really generated by the model DGP.
%
% Compare two approaches: a time-domain approach, and a frequency-domain
% approach. Use the singular value decomposition to learn more about which
% parameters (or combinations of them) are identified the best or the
% worst.

%% Clear Workspace
%
% Clear workspace, close all graphics figures, clear command window, and
% check the IRIS version.

clear; clc; close all
irisrequired 20151016

%% Load Solved Model Object
%
% Load the solved model object built in `read_linear_model`. Run `read_linear_model` at
% least once before running this m-file.

load read_linear_model m;

%% Calculate Fisher Information Matrix
%
% The Fisher information matrix is a useful tools examining how much
% information can be recovered from the data to identify some of the model
% parameters (under the assumption that the model with its current
% parameters is the true DGP).
%
% Compute the Fisher information matrix using two approaches:
% * a simulation method in the time domain.
% * an analytical method in the frequency domain.
%
% The results are asymptotically equivalent. The actual differencies
% observed in this exercise arise because of
%
% * sampling errors in the time domain,
% * the fact that the frequency domain approach assumes that the model
% variables follow a circular process (which is not true for samples of
% finite lenthgs).
%
% The differences and other approximation errors are though usually
% immaterial for detecting identification deficiencies.

rng(0);

% List of parameters for which for which the Fisher matrix will be
% evaluated.
load P
plist = fieldnames(P);

% Set to a larger number in practice.
nsim = 100;

fprintf('Resample %g times from calibrated model.\n',nsim);

% Simulate a total of nsim artificial data, length 40 periods.
range = 1:40;
d = resample(m,[],range,nsim);

disp('Compute Hessians for each draw and average them.');

load read_data.mat d
range = dbrange(d); range(1) = []; % drop 1959Q2

[mloglik,s,F1] = diffloglik(m,d,range,plist, ...
   'sstate=',true,'relative=',false,'objRange=',range(3:end),'progress=',true);

F1 = mean(F1,3);

disp('Compute information matrix in frequency domain.');
[F2,F2i,d] = fisher(m,40,plist, ...
    'deviation=',false,'progress=',true);

format shortEng;
disp('Compare time-domain and frequency domain info matrices.');
disp('Time domain');
F1 %#ok<NOPTS>
disp('Frequency domain');
F2 %#ok<NOPTS>

disp('Compare diagonal elements');
[diag(F1),diag(F2)] %#ok<NOPTS>
format();

%% Singular Value Decomposition
%
% The singular value decomposition is a quick way how to find out which
% parameters or combinations of parameters are identified the best or the
% worst.

% TODO: Correct for the absolute size of the parameters.

[u1,s1] = svd(F1);
[u2,s2] = svd(F2);

s1 = diag(s1);
s2 = diag(s2);
s1 = s1 / s1(1);
s2 = s2 / s2(1);

format('shortEng');
disp('Singular values (normalised and ordered)');
disp('Time domain');
disp(s1.');
disp('Frequency domain');
disp(s2.');

disp('Combinations of parameters ordered by degree of identification.');
disp('Best identified columns ordered first');

disp('Time domain');
[char(plist),num2str(u1,'| %-.2g')] %#ok<NOPTS>
disp('Frequency domain');
[char(plist),num2str(u2,'| %-.2g')] %#ok<NOPTS>
format();

%% Help on IRIS Functions Used in This File
%
% Use either `help` to display help in the command window, or `idoc`
% to display help in an HTML browser window.
%
%    help model/resample
%    help model/fisher
%    help model/diffloglik
